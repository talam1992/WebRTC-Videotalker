{"ast":null,"code":"import store from '../../store/store';\nimport { callStates, setCallerUsername, setCallingDialogVisible, setCallRejected, setCallState, setLocalStream } from \"../../store/actions/callActions\";\nimport * as wss from '../wssConnection/wssConnection';\nconst preOfferAnswers = {\n  CALL_ACCEPTED: 'CALL_ACCEPTED',\n  CALL_REJECTED: 'CALL_REJECTED',\n  CALL_NOT_AVAILABLE: 'CALL_NOT_AVAILABLE'\n};\nconst defaultConstrains = {\n  video: true,\n  audio: true\n};\nconst configuration = {\n  iceServers: [{\n    urls: 'stun:stun.l.google.com:13902'\n  }]\n};\nlet connectedUserSocketId;\nlet peerConnection;\nexport const getLocalStream = () => {\n  navigator.mediaDevices.getUserMedia(defaultConstrains).then(stream => {\n    store.dispatch(setLocalStream(stream));\n    store.dispatch(setCallState(callStates.CALL_AVAILABLE));\n    createPeerConnection();\n  }).catch(err => {\n    console.log('error occured when trying to get access to get local stream');\n    console.log(err);\n  });\n};\n\nconst createPeerConnection = () => {\n  peerConnection = new RTCPeerConnection(configuration);\n  const localStream = store.getState().call.localStream;\n\n  for (const track of localStream.getTracks()) {\n    peerConnection.addTrack(track, localStream);\n  }\n\n  ;\n\n  peerConnection.ontrack = ({\n    streams: [stream]\n  }) => {// dispatch remote stream in our store\n  };\n\n  peerConnection.onicecandidate = event => {\n    // send to connected user our ice candidate\n    console.log('getting candidates from stun server');\n\n    if (event.candidate) {\n      wss.sendWebRTCCandidate({\n        candidate: event.candidate,\n        connectedUserSocketId: connectedUserSocketId\n      });\n    }\n  };\n\n  peerConnection.ononnectionstatechange = event => {\n    if (peerConnection.connectionState === 'connected') {\n      console.log('succesfully connected with other peer');\n    }\n  };\n};\n\nexport const callToOtherUser = calleeDetails => {\n  connectedUserSocketId = calleeDetails.socketId;\n  store.dispatch(setCallState(callStates.CALL_IN_PROGRESS));\n  store.dispatch(setCallingDialogVisible(true));\n  wss.sendPreOffer({\n    callee: calleeDetails,\n    caller: {\n      username: store.getState().dashboard.username\n    }\n  });\n};\nexport const handlePreOffer = data => {\n  if (checkIfCallIsPossible()) {\n    connectedUserSocketId = data.callerSocketId;\n    store.dispatch(setCallerUsername(data.callerUsername));\n    store.dispatch(setCallState(callStates.CALL_REQUESTED));\n  } else {\n    wss.sendPreOfferAnswer({\n      callerSocketId: data.callerSocketId,\n      answer: preOfferAnswers.CALL_NOT_AVAILABLE\n    });\n  }\n};\nexport const acceptIncommingCallRequest = () => {\n  wss.sendPreOfferAnswer({\n    callerSocketId: connectedUserSocketId,\n    answer: preOfferAnswers.CALL_ACCEPTED\n  });\n};\nexport const rejectIncommingCallRequest = () => {\n  wss.sendPreOfferAnswer({\n    callerSocketId: connectedUserSocketId,\n    answer: preOfferAnswers.CALL_REJECTED\n  });\n  resetCallData();\n};\n\nconst sendOffer = async () => {\n  const offer = await peerConnection.createOffer();\n  await peerConnection.setLocalDescription(offer);\n  wss.sendWebRTCOffer({\n    calleeSocketId: connectedUserSocketId,\n    offer: offer\n  });\n};\n\nexport const handleOffer = async data => {\n  await peerConnection.setRemoteDescription(data.offer);\n  const answer = await peerConnection.createAnswer();\n  await peerConnection.setLocalDescription(answer);\n  wss.sendWebRTCAnswer({\n    callerSocketId: connectedUserSocketId,\n    answer: answer\n  });\n};\nexport const handleAnswer = async data => {\n  await peerConnection.setRemoteDescription(data.answer);\n};\nexport const handleCandidate = async data => {\n  try {\n    console.log('adding ice candidates');\n    await peerConnection.addIceCandidcate(data.candidate);\n  } catch (err) {\n    console.error('error occured when trying to add recieved ice candidate', err);\n  }\n};\nexport const handlePreOfferAnswer = data => {\n  store.dispatch(setCallingDialogVisible(false));\n\n  if (data.answer === preOfferAnswers.CALL_ACCEPTED) {\n    // send webRTC offer\n    sendOffer();\n  } else {\n    let rejectionReason;\n\n    if (data.answer === preOfferAnswers.CALL_NOT_AVAILABLE) {\n      rejectionReason = 'Callee is not able to pick up the call right now';\n    } else {\n      rejectionReason = 'Call rejected by the callee';\n    }\n\n    store.dispatch(setCallRejected({\n      rejected: true,\n      reason: rejectionReason\n    }));\n    resetCallData();\n  }\n};\nexport const checkIfCallIsPossible = () => {\n  if (store.getState().call.localStream === null || store.getState().call.callState !== callStates.CALL_AVAILABLE) {\n    return false;\n  } else {\n    return true;\n  }\n};\nexport const resetCallData = () => {\n  connectedUserSocketId = null;\n  store.dispatch(setCallState(callStates.CALL_AVAILABLE));\n};","map":{"version":3,"sources":["C:/Users/Timothy Lam/Documents/GitHub/WebRTC-Videotalker/video-talker-frontend/src/utils/webRTC/webRTCHandler.js"],"names":["store","callStates","setCallerUsername","setCallingDialogVisible","setCallRejected","setCallState","setLocalStream","wss","preOfferAnswers","CALL_ACCEPTED","CALL_REJECTED","CALL_NOT_AVAILABLE","defaultConstrains","video","audio","configuration","iceServers","urls","connectedUserSocketId","peerConnection","getLocalStream","navigator","mediaDevices","getUserMedia","then","stream","dispatch","CALL_AVAILABLE","createPeerConnection","catch","err","console","log","RTCPeerConnection","localStream","getState","call","track","getTracks","addTrack","ontrack","streams","onicecandidate","event","candidate","sendWebRTCCandidate","ononnectionstatechange","connectionState","callToOtherUser","calleeDetails","socketId","CALL_IN_PROGRESS","sendPreOffer","callee","caller","username","dashboard","handlePreOffer","data","checkIfCallIsPossible","callerSocketId","callerUsername","CALL_REQUESTED","sendPreOfferAnswer","answer","acceptIncommingCallRequest","rejectIncommingCallRequest","resetCallData","sendOffer","offer","createOffer","setLocalDescription","sendWebRTCOffer","calleeSocketId","handleOffer","setRemoteDescription","createAnswer","sendWebRTCAnswer","handleAnswer","handleCandidate","addIceCandidcate","error","handlePreOfferAnswer","rejectionReason","rejected","reason","callState"],"mappings":"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","sourcesContent":["import store from '../../store/store';\r\nimport { callStates, setCallerUsername, setCallingDialogVisible, setCallRejected, setCallState, setLocalStream } from \"../../store/actions/callActions\";\r\nimport * as wss from '../wssConnection/wssConnection';\r\n\r\nconst preOfferAnswers = {\r\n    CALL_ACCEPTED: 'CALL_ACCEPTED',\r\n    CALL_REJECTED: 'CALL_REJECTED',\r\n    CALL_NOT_AVAILABLE: 'CALL_NOT_AVAILABLE'\r\n};\r\n\r\nconst defaultConstrains = {\r\n    video: true,\r\n    audio: true\r\n};\r\n\r\nconst configuration = {\r\n    iceServers: [{\r\n        urls: 'stun:stun.l.google.com:13902'\r\n    }]\r\n};\r\n\r\nlet connectedUserSocketId;\r\nlet peerConnection;\r\n\r\nexport const getLocalStream = () => {\r\n    navigator.mediaDevices.getUserMedia(defaultConstrains)\r\n    .then(stream => {\r\n        store.dispatch(setLocalStream(stream));\r\n        store.dispatch(setCallState(callStates.CALL_AVAILABLE));\r\n        createPeerConnection();\r\n    })\r\n    .catch(err => {\r\n        console.log('error occured when trying to get access to get local stream');\r\n        console.log(err);\r\n    });\r\n}\r\n;\r\n\r\nconst createPeerConnection = () => {\r\n    peerConnection = new RTCPeerConnection(configuration);\r\n\r\n    const localStream = store.getState().call.localStream;\r\n\r\n    for (const track of localStream.getTracks()) {\r\n        peerConnection.addTrack(track, localStream);\r\n    };\r\n\r\n    peerConnection.ontrack = ({ streams: [stream] }) => {\r\n        // dispatch remote stream in our store\r\n    }\r\n\r\n    peerConnection.onicecandidate = (event) => {\r\n        // send to connected user our ice candidate\r\n        console.log('getting candidates from stun server');\r\n        if(event.candidate) {\r\n            wss.sendWebRTCCandidate({\r\n                candidate: event.candidate,\r\n                connectedUserSocketId: connectedUserSocketId\r\n            });\r\n        }\r\n    };\r\n\r\n    peerConnection.ononnectionstatechange = (event) => {\r\n        if (peerConnection.connectionState === 'connected') {\r\n            console.log('succesfully connected with other peer');\r\n        }\r\n    };\r\n};\r\n\r\nexport const callToOtherUser = (calleeDetails) => {\r\n    connectedUserSocketId = calleeDetails.socketId;\r\n    store.dispatch(setCallState(callStates.CALL_IN_PROGRESS));\r\n    store.dispatch(setCallingDialogVisible(true));\r\n    wss.sendPreOffer({\r\n        callee: calleeDetails,\r\n        caller: {\r\n            username: store.getState().dashboard.username\r\n        }\r\n    });\r\n};\r\n\r\nexport const handlePreOffer = (data) => {\r\n\r\n    if(checkIfCallIsPossible()) {\r\n        connectedUserSocketId = data.callerSocketId;\r\n        store.dispatch(setCallerUsername(data.callerUsername));\r\n        store.dispatch(setCallState(callStates.CALL_REQUESTED));\r\n    } else {\r\n        wss.sendPreOfferAnswer({\r\n            callerSocketId: data.callerSocketId,\r\n            answer: preOfferAnswers.CALL_NOT_AVAILABLE\r\n        });\r\n    }\r\n};\r\n\r\nexport const acceptIncommingCallRequest = () => {\r\n    wss.sendPreOfferAnswer({\r\n        callerSocketId: connectedUserSocketId,\r\n        answer: preOfferAnswers.CALL_ACCEPTED\r\n    });\r\n};\r\n\r\nexport const rejectIncommingCallRequest = () => {\r\n    wss.sendPreOfferAnswer({\r\n        callerSocketId: connectedUserSocketId,\r\n        answer: preOfferAnswers.CALL_REJECTED\r\n    });\r\n\r\n    resetCallData();\r\n};\r\n\r\nconst sendOffer = async () => {\r\n    const offer = await peerConnection.createOffer();\r\n    await peerConnection.setLocalDescription(offer);\r\n    wss.sendWebRTCOffer({\r\n        calleeSocketId: connectedUserSocketId,\r\n        offer: offer\r\n    });\r\n};\r\n\r\nexport const handleOffer = async (data) => {\r\n    await peerConnection.setRemoteDescription(data.offer);\r\n    const answer = await peerConnection.createAnswer();\r\n    await peerConnection.setLocalDescription(answer);\r\n    wss.sendWebRTCAnswer({\r\n        callerSocketId: connectedUserSocketId,\r\n        answer: answer\r\n    });\r\n};\r\n\r\nexport const handleAnswer = async (data) => {\r\n    await peerConnection.setRemoteDescription(data.answer);\r\n};\r\n\r\nexport const handleCandidate = async (data) => {\r\n    try{\r\n        console.log('adding ice candidates');\r\n        await peerConnection.addIceCandidcate(data.candidate);\r\n    } catch (err) {\r\n        console.error('error occured when trying to add recieved ice candidate', err);\r\n    }\r\n};\r\n\r\nexport const handlePreOfferAnswer = (data) => {\r\n\r\n    store.dispatch(setCallingDialogVisible(false));\r\n\r\n    if (data.answer === preOfferAnswers.CALL_ACCEPTED) {\r\n        // send webRTC offer\r\n        sendOffer();\r\n    } else {\r\n        let rejectionReason;\r\n        if (data.answer === preOfferAnswers.CALL_NOT_AVAILABLE) {\r\n            rejectionReason = 'Callee is not able to pick up the call right now';\r\n        } else {\r\n            rejectionReason = 'Call rejected by the callee';\r\n        }\r\n        store.dispatch(setCallRejected({\r\n            rejected: true,\r\n            reason: rejectionReason\r\n        }));\r\n\r\n        resetCallData();\r\n    }\r\n};\r\n\r\nexport const checkIfCallIsPossible = () => {\r\n    if(store.getState().call.localStream === null ||\r\n    store.getState().call.callState !== callStates.CALL_AVAILABLE) {\r\n        return false;\r\n    } else {\r\n        return true;\r\n    }\r\n};\r\n\r\nexport const resetCallData = () => {\r\n    connectedUserSocketId = null;\r\n    store.dispatch(setCallState(callStates.CALL_AVAILABLE));\r\n};"]},"metadata":{},"sourceType":"module"}